/**
 * Alice Wake Word Detection
 * Enkel men effektiv wake-word detection för "Alice" med olika uttals-varianter
 */

export class WakeWordDetector {
    constructor(audioContext, options = {}) {
        this.audioContext = audioContext;
        this.isInitialized = false;
        this.isListening = false;
        this.callbacks = {};
        
        // Wake word konfiguration
        this.config = {
            wakeWords: options.wakeWords || ['alice', 'allis', 'alis', 'alicia'],
            sensitivity: options.sensitivity || 0.7,  // 0.0 - 1.0
            cooldownMs: options.cooldownMs || 2000,   // Tid mellan detections
            maxRecordingMs: options.maxRecordingMs || 3000, // Max inspelningstid
            language: options.language || 'sv-SE',
            continuous: options.continuous !== false,  // Default true
        };
        
        // State
        this.state = {
            lastDetection: 0,
            isInCooldown: false,
            currentRecording: null,
            recordingStartTime: 0,
        };
        
        // Speech recognition för wake-word detection
        this.recognition = null;
        this.setupWakeWordRecognition();
    }
    
    setupWakeWordRecognition() {
        if (typeof window === 'undefined') {
            console.warn('WakeWord: Not in browser environment');
            return;
        }
        
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
            console.error('WakeWord: Speech recognition not supported');
            return;
        }
        
        try {
            this.recognition = new SpeechRecognition();
            
            // Optimera för wake-word detection
            this.recognition.continuous = this.config.continuous;\n            this.recognition.interimResults = true;  // För snabbare detection\n            this.recognition.lang = this.config.language;\n            this.recognition.maxAlternatives = 3;  // Fler alternativ för bättre matching\n            \n            // Lägre confidence threshold för wake-words\n            if (this.recognition.webkitSpeechRecognition) {\n                // Chrome-specifika optimeringar\n                this.recognition.serviceURI = 'wss://www.google.com/speech-api/v2/recognize';\n            }\n            \n            this.setupRecognitionEvents();\n            this.isInitialized = true;\n            \n            console.log('WakeWord: Wake word detector initialized');\n            \n        } catch (error) {\n            console.error('WakeWord: Failed to setup wake word recognition:', error);\n            this.isInitialized = false;\n        }\n    }\n    \n    setupRecognitionEvents() {\n        if (!this.recognition) return;\n        \n        this.recognition.onstart = () => {\n            this.isListening = true;\n            console.log('WakeWord: Started listening for wake words');\n            this.emit('listening_started');\n        };\n        \n        this.recognition.onend = () => {\n            this.isListening = false;\n            console.log('WakeWord: Stopped listening for wake words');\n            this.emit('listening_stopped');\n            \n            // Auto-restart om continuous mode\n            if (this.config.continuous && !this.state.isInCooldown) {\n                setTimeout(() => {\n                    if (this.isInitialized && !this.isListening) {\n                        this.startListening();\n                    }\n                }, 100); // Kort delay för att undvika spam\n            }\n        };\n        \n        this.recognition.onerror = (event) => {\n            console.error('WakeWord: Recognition error:', event.error);\n            this.emit('error', event.error);\n            \n            // Hantera specifika fel\n            if (event.error === 'no-speech') {\n                // Normalt för wake-word detection, fortsätt\n                return;\n            }\n            \n            if (event.error === 'network') {\n                // Network error, försök igen efter delay\n                setTimeout(() => {\n                    if (this.config.continuous) {\n                        this.startListening();\n                    }\n                }, 5000);\n            }\n        };\n        \n        this.recognition.onresult = (event) => {\n            const result = event.results[event.results.length - 1];\n            const transcript = result[0].transcript.toLowerCase().trim();\n            const confidence = result[0].confidence || 0;\n            const isFinal = result.isFinal;\n            \n            console.log('WakeWord: Heard:', transcript, 'confidence:', confidence, 'final:', isFinal);\n            \n            // Analysera även interim results för snabbare detection\n            if (this.detectWakeWord(transcript, confidence)) {\n                this.onWakeWordDetected(transcript, confidence, isFinal);\n            }\n        };\n    }\n    \n    /**\n     * Detektera wake-word i transcript\n     */\n    detectWakeWord(transcript, confidence) {\n        if (!transcript) return false;\n        \n        // Kontrollera cooldown\n        const now = Date.now();\n        if (this.state.isInCooldown || now - this.state.lastDetection < this.config.cooldownMs) {\n            return false;\n        }\n        \n        // Normalisera transcript\n        const normalizedTranscript = transcript\n            .replace(/[.,!?;]/g, '')  // Ta bort interpunktion\n            .replace(/\\s+/g, ' ')     // Normalisera mellanslag\n            .toLowerCase()\n            .trim();\n        \n        // Sök efter wake-words\n        for (const wakeWord of this.config.wakeWords) {\n            if (this.matchesWakeWord(normalizedTranscript, wakeWord, confidence)) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    /**\n     * Matcha en specifik wake-word med fuzzy matching\n     */\n    matchesWakeWord(transcript, wakeWord, confidence) {\n        const words = transcript.split(' ');\n        \n        // Exakt match\n        if (words.includes(wakeWord)) {\n            console.log(`WakeWord: Exact match found: \"${wakeWord}\"`);\n            return confidence >= this.config.sensitivity * 0.5; // Lägre threshold för exakt match\n        }\n        \n        // Fuzzy match för varje ord\n        for (const word of words) {\n            if (this.fuzzyMatch(word, wakeWord)) {\n                console.log(`WakeWord: Fuzzy match found: \"${word}\" ≈ \"${wakeWord}\"`);\n                return confidence >= this.config.sensitivity;\n            }\n        }\n        \n        // Partiell match (wake-word som del av ord)\n        for (const word of words) {\n            if (word.includes(wakeWord) || wakeWord.includes(word)) {\n                if (Math.abs(word.length - wakeWord.length) <= 2) {\n                    console.log(`WakeWord: Partial match found: \"${word}\" ~ \"${wakeWord}\"`);\n                    return confidence >= this.config.sensitivity * 1.2; // Högre threshold för partial\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    /**\n     * Enkel fuzzy matching baserad på Levenshtein-liknande logik\n     */\n    fuzzyMatch(word1, word2) {\n        const maxLength = Math.max(word1.length, word2.length);\n        if (maxLength === 0) return true;\n        \n        const distance = this.levenshteinDistance(word1, word2);\n        const similarity = (maxLength - distance) / maxLength;\n        \n        // Tillåt mer variation för längre ord\n        const threshold = maxLength <= 4 ? 0.75 : 0.7;\n        \n        return similarity >= threshold;\n    }\n    \n    /**\n     * Beräkna Levenshtein distance mellan två strängar\n     */\n    levenshteinDistance(str1, str2) {\n        const matrix = [];\n        \n        for (let i = 0; i <= str2.length; i++) {\n            matrix[i] = [i];\n        }\n        \n        for (let j = 0; j <= str1.length; j++) {\n            matrix[0][j] = j;\n        }\n        \n        for (let i = 1; i <= str2.length; i++) {\n            for (let j = 1; j <= str1.length; j++) {\n                if (str2.charAt(i - 1) === str1.charAt(j - 1)) {\n                    matrix[i][j] = matrix[i - 1][j - 1];\n                } else {\n                    matrix[i][j] = Math.min(\n                        matrix[i - 1][j - 1] + 1,\n                        matrix[i][j - 1] + 1,\n                        matrix[i - 1][j] + 1\n                    );\n                }\n            }\n        }\n        \n        return matrix[str2.length][str1.length];\n    }\n    \n    /**\n     * Wake-word detected event\n     */\n    onWakeWordDetected(transcript, confidence, isFinal) {\n        const now = Date.now();\n        \n        this.state.lastDetection = now;\n        this.state.isInCooldown = true;\n        \n        console.log('WakeWord: ALICE detected!', { transcript, confidence, isFinal });\n        \n        this.emit('wake_word_detected', {\n            transcript,\n            confidence,\n            isFinal,\n            timestamp: now,\n            wakeWords: this.config.wakeWords\n        });\n        \n        // Starta cooldown\n        setTimeout(() => {\n            this.state.isInCooldown = false;\n            console.log('WakeWord: Cooldown ended, resuming detection');\n            this.emit('cooldown_ended');\n        }, this.config.cooldownMs);\n        \n        // Stoppa lysning temporärt för att ge plats åt huvuddialog\n        if (this.isListening) {\n            this.recognition.stop();\n        }\n    }\n    \n    /**\n     * Starta wake-word detection\n     */\n    start() {\n        if (!this.isInitialized) {\n            console.error('WakeWord: Not initialized');\n            return false;\n        }\n        \n        if (this.isListening) {\n            console.log('WakeWord: Already listening');\n            return true;\n        }\n        \n        return this.startListening();\n    }\n    \n    startListening() {\n        if (!this.recognition) return false;\n        \n        try {\n            this.recognition.start();\n            return true;\n        } catch (error) {\n            console.error('WakeWord: Failed to start listening:', error);\n            return false;\n        }\n    }\n    \n    /**\n     * Stoppa wake-word detection\n     */\n    stop() {\n        if (this.recognition && this.isListening) {\n            this.recognition.stop();\n        }\n        this.state.isInCooldown = false;\n        console.log('WakeWord: Wake word detection stopped');\n    }\n    \n    /**\n     * Pausa temporärt (för conversations)\n     */\n    pause() {\n        if (this.isListening) {\n            this.recognition.stop();\n            console.log('WakeWord: Paused for conversation');\n        }\n    }\n    \n    /**\n     * Återuppta efter paus\n     */\n    resume() {\n        if (this.config.continuous && !this.isListening && !this.state.isInCooldown) {\n            setTimeout(() => {\n                this.startListening();\n                console.log('WakeWord: Resumed after conversation');\n            }, 1000); // Kort delay\n        }\n    }\n    \n    /**\n     * Uppdatera konfiguration\n     */\n    updateConfig(newConfig) {\n        this.config = { ...this.config, ...newConfig };\n        console.log('WakeWord: Configuration updated:', newConfig);\n    }\n    \n    /**\n     * Hämta status\n     */\n    getStatus() {\n        return {\n            isInitialized: this.isInitialized,\n            isListening: this.isListening,\n            isInCooldown: this.state.isInCooldown,\n            lastDetection: this.state.lastDetection,\n            wakeWords: this.config.wakeWords,\n            sensitivity: this.config.sensitivity,\n            continuous: this.config.continuous,\n            timeSinceLastDetection: this.state.lastDetection > 0 ? \n                Date.now() - this.state.lastDetection : null\n        };\n    }\n    \n    /**\n     * Test wake-word matching (för debugging)\n     */\n    testWakeWord(text, confidence = 1.0) {\n        console.log('WakeWord: Testing:', text);\n        const result = this.detectWakeWord(text.toLowerCase(), confidence);\n        console.log('WakeWord: Test result:', result);\n        return result;\n    }\n    \n    /**\n     * Event system\n     */\n    on(event, callback) {\n        if (!this.callbacks[event]) {\n            this.callbacks[event] = [];\n        }\n        this.callbacks[event].push(callback);\n    }\n    \n    off(event, callback) {\n        if (this.callbacks[event]) {\n            const index = this.callbacks[event].indexOf(callback);\n            if (index > -1) {\n                this.callbacks[event].splice(index, 1);\n            }\n        }\n    }\n    \n    emit(event, data = null) {\n        if (this.callbacks[event]) {\n            this.callbacks[event].forEach(callback => {\n                try {\n                    callback(data);\n                } catch (error) {\n                    console.error('WakeWord: Event callback error:', error);\n                }\n            });\n        }\n    }\n    \n    /**\n     * Cleanup\n     */\n    dispose() {\n        this.stop();\n        this.callbacks = {};\n        this.isInitialized = false;\n        console.log('WakeWord: Disposed');\n    }\n}\n\n// Utility functions\nexport function createWakeWordDetector(audioContext, options = {}) {\n    return new WakeWordDetector(audioContext, options);\n}\n\n// Fördefinierade svenska wake-word uppsättningar\nexport const SWEDISH_WAKE_WORDS = {\n    alice: ['alice', 'allis', 'alis', 'alicia', 'alex'],\n    hej_alice: ['hej alice', 'hej allis', 'hello alice', 'hi alice'],\n    alla: ['alice', 'allis', 'alis', 'alicia', 'alex', 'hej alice', 'hello alice']\n};"